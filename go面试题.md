参考链接：https://www.zhihu.com/tardis/zm/art/519979757?source_id=1003

[TOC]

## Golang语言的特性

- 语法简单，易于学习和阅读
- 源码级支持协程，实现简单；对比进程和线程，协程占用资源少，能够简洁高效地处理高并发问题
- **编译型语言**，通过静态类型检查和编译优化，能够生成高效的本地机器码。这有助于提高程序的性能。
- Go 语言通过指针的限制和**内存安全**的设计，降低了程序出现内存泄漏和缓冲区溢出等问题的风险。
- **静态类型语言**，编译器在编译时进行类型检查，提前发现潜在的类型错误。这有助于减少运行时错误，提高代码的可维护性。

## make 和 new 的区别？

**`new` 函数：**

- **分配值类型的内存**，如结构体、整数、浮点数等，返回的是指向变量的指针。
-  **不会初始化内存**，分配的内存会被置为零值。

**`make`函数**：

- **分配引用类型的内存**，如slice、map、chan，返回的是变量本身（初始化后的实例）。
- **make会初始化分配的内存**

## defer

**作用**：defer延迟函数，释放资源，收尾工作；如释放锁，关闭文件，关闭链接；捕获panic;

**避坑指南**：defer函数紧跟在资源打开后面，否则defer可能得不到执行，导致内存泄露。

多个 defer 调用顺序是 LIFO（后入先出），defer后的操作可以理解为压入栈中

每个 defer 语句都对应一个_defer 实例，使用指针连接起来形成一个单连表，保存在 gotoutine 数据结构中，每次插入_defer 实例，均插入到链表的头部，函数结束时再一次从头部取出，从而形成后进先出的效果。

## rune 类型

`rune` 是一种用于表示 Unicode 的数据类型。`rune` 类型实际上是一个 int32 的类型，它用来表示一个 Unicode 字符。

Go 语言中的字符串是由 `byte` 字节组成的切片，而 `rune` 是为了处理 Unicode 字符而引入的。一个字符串中的字符可能是一个或多个 `byte`，而一个 `rune` 则对应一个 Unicode 字符。

rune 常用来处理unicode或utf-8字符

## 传值 VS 传指针

传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的是同一个对象呢。传指针可以减少值的拷贝，但是会导致**内存分配逃逸到堆中**，**增加垃圾回收(GC)的负担**。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。

一般情况下，**对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能**。

## 数组和切片

### 数组

数组是一个**固定大小**的数据结构，数组长度在创建时确定，不可更改。数组是**值类型**，将一个数组赋值给另外一个数组时，会复制整个数组的值。

### 切片

切片**引用类型**，引用了一个底层数组。当将一个切片赋值给另一个切片时，它们实际上引用相同的底层数组，修改值将会影响其他的切片。

切片长度：**切片的起始位置到切片的结束位置的元素数量**

切片容量：**切片的起始位置到底层数组的末尾的元素数量**

### 切片的扩容

扩容操作只关心容量，会把原slice的数据拷贝至新slice中，扩容规则：

go 1.18之前：

- 原slice的容量小于1024，则新slice的容量将扩大为原来的2倍；
- 原slice的容量大于1024，则新的slice的容量将扩大为原来的1.25倍；

go 1.18更新之后：

当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap = oldcap+(oldcap+3*256)/4

### 切片扩容引发的问题

因为有扩容机制。所以无法保证**原始的slice**和用append后的**新slice**指向同一个底层数组，也无法证明它们就指向不同的底层数组。

- 当 append 之后的长度小于等于 cap，将会直接利用原底层数组剩余的空间。
- 当 append 后的长度大于 cap 时，则会分配一块更大的区域来容纳新的底层数组。

### 使用range进行切片迭代问题 （go1.22之前的版本中）

在 for a,b := range c 遍历中， a 和 b 在内存中只会存在一份，即之后每次循环时遍历到的数据都是以值覆盖的方式赋给 a 和 b，a，b 的内存地址始终不变。由于有这个特性，for 循环里面如果开协程，不要直接把 a 或者 b 的地址传给协程。解决办法：在每次循环时，创建一个临时变量。

### 性能陷阱

#### 大量内存得不到释放

在已有切片的基础上进行切片，不会创建新的底层数组。因为原来的底层数组没有发生变化，内存会一直占用，直到没有变量引用该数组。因此很可能出现这么一种情况，原切片由大量的元素构成，但是我们在原切片的基础上切片，虽然只使用了很小一段，但底层数组在内存中仍然占据了大量空间，得不到释放。比较推荐的做法，使用 `copy` 创建一个新切片。

## map

Go 语言采用的是哈希表，并且使用链表解决哈希冲突，（即在同一个桶中使用链表来存储具有相同哈希码的键值对）

每个桶中保存了8个kv对，如果8个满了，又来了一个key落在了这个桶里，会使用overflow连接下一个桶(溢出桶)。

### map的赋值流程

- 通过key的hash值后“B”位确定是哪一个桶
- 遍历当前桶，通过key的tophash和hash值，防止key重复，然后**找到第一个可以插入的位置**，即空位置处存储数据。
- 如果**当前桶元素已满，会通过overflow链接创建一个新的桶**，来存储数据。

### map 获取数据流程

- 计算key的hash值
- 通过最后的“B”位来确定在哪号桶
- 根据key对应的hash值前8位快速确定是在这个桶的哪个位置**（额外说明一下，在bmap中存放了每个key对应的tophash，是key的哈希值前8位),一旦发现前8位一致，则会执行下一步**
- 对比key完整的hash是否匹配，如果匹配则获取对应value
- 如果都没有找到，就去连接的下一个溢出桶中找

### 怎么处理对 map 进行并发访问

- 使用内置**`sync.Map`**：适用于读多写少的场景，内部使用 read 和 dirty 两个 map 来进行读写分离，降低锁时间来提高效率。使用方法：

  Store写入、Load读取、Range遍历、Delete删除，LoadOrStore读或写

  原理：

  ```
  type Map struct {
  	mu Mutex
  	read atomic.Value // readOnly
  	dirty map[interface{}]*entry
  	misses int
  }
  ```

- 使用读写锁实现并发安全map

### Map扩容

当 map 装载因子超过阈值，源码里定义的阈值是 6.5。Go 语言会触发 map 的扩容操作。扩容时，Go 会创建一个新的更大的哈希表，然后将旧表中的键值对重新哈希并存储到新表中。这样做的目的是为了减小哈希冲突，提高哈希表的性能。在扩容过程中，所有读写操作仍然是安全的，因为 Go 语言会使用锁来保护这个操作。

## go内存管理机制

Go语言的内存管理机制是通过垃圾回收（Garbage Collection，GC）来实现的。下面是Go语言内存管理的基本原理：

1. **自动内存分配：** Go语言使用自动内存分配，开发者无需手动分配和释放内存。这由垃圾回收器（Garbage Collector）负责。
2. **垃圾回收（GC）：** 垃圾回收是Go语言内存管理的核心机制。**Go的垃圾回收器会定期扫描程序中不再使用的内存，将其标记为可回收的垃圾，然后释放这些垃圾占用的内存。**这使得开发者不必手动管理内存，大大简化了内存管理的复杂性。
3. **并发垃圾回收：** Go的垃圾回收器是并发的，它可以在程序继续执行的同时进行垃圾回收。这意味着垃圾回收不会阻塞整个程序的执行，减小了对程序性能的影响。
4. **分代回收：** Go的垃圾回收器采用分代回收策略。它将内存分为不同的代（generation），一般分为新生代和老生代。新分配的对象首先被分配到新生代，只有经过一定次数的垃圾回收后，仍然存活的对象才会被晋升到老生代。分代回收能够更有效地处理不同生命周期的对象。
5. **写屏障（Write Barrier）：** Go语言的垃圾回收器使用写屏障技术，即在进行垃圾回收时，会拦截对指针的写入操作，以便准确地追踪对象的引用关系。这有助于垃圾回收器准确地标记和回收不再被引用的对象。
6. **内存分配器：** Go语言的运行时系统包含了一个内存分配器，负责分配和释放内存。内存分配器会根据对象的大小选择合适的内存池，以提高内存分配效率。

## 逃逸分析

逃逸分析是编译器用于确定变量的生命周期是否超出了函数范围的一种静态分析技术。逃逸分析主要用于优化内存分配和提高程序性能。

Go语言中的函数内部创建的变量可以分为两种：

1. **栈上分配（Stack Allocation）：** 局部变量在函数调用时被分配在栈上，并在函数返回时被自动释放。这种情况下，变量的生命周期被限制在函数的范围内。
2. **堆上分配（Heap Allocation）：** 如果一个变量的引用逃逸到函数外部（例如返回函数的指针或保存到全局变量），编译器可能会决定将该变量分配在堆上，以确保它在函数返回后仍然可以访问。这样的变量生命周期可能会超出函数范围，需要通过垃圾回收进行管理。

**逃逸分析的情况：**

- **指针逃逸**：即在函数中创建了一个对象，返回了这个对象的指针。这种情况下，函数虽然退出了，但是因为指针的存在，对象的内存不能随着函数结束而回收，因此只能分配在堆上。
- interface{} **动态类型逃逸**：空接口即 `interface{}` 可以表示任意的类型，如果函数参数为 `interface{}`，编译期间很难确定其参数的具体类型，也会发生逃逸。
- 闭包：闭包让你可以在一个内层函数中访问到其外层函数的作用域，如果在闭包中访问当前函数的变量，为了不在函数结束时，释放改变量，会发生逃逸。

**如何利用逃逸分析提升性能**

传值 VS 传指针：

传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。

一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能。

## select 多路复用

go 的 select 为 golang 提供了多路 IO 复用机制，和其他 IO 复用一样，用于检测读写事件是否 ready。

一个协程时常会处理多个通道，当不希望一个通道的读写陷入堵塞影响到其他通道的正常读写。**可使用select多路复用的机制同时监听多个通道是否准备就绪。**select在底层会锁住所有的通道并采取随机的方式保证公平地遍历所有的通道。

## context

### 结构

```
type Context interface {
	Deadline() (deadline time.Time, ok bool)
	Done() <-chan struct{}
	Err() error
	Value(key any) any
}
```

- Deadline 方法返回一个 time.Time，表示当前 Context 应该结束的时间，ok 则表示有结束时间。
- Done 方法当 Context 被取消或者超时时候返回的一个 close 的 channel，告诉给 context 相关的函数要停止当前工作然后返回了。
- Err 表示 context 被取消的原因。
- Value 方法表示 context 实现共享数据存储的地方，是协程安全的。

### 初始化方法

- WithDeadline：返回一个带有截止日期的上下文，当超过截止日期时，该上下文会自动取消。
- WithTimeout：是 `WithDeadline` 的一个简化版本，用于设置相对时间的超时。
- WithCancel：返回一个带有取消信号的上下文，同时返回一个 `cancel` 函数，用于取消该上下文。
- WithValue：创建了个带有键值对数据的上下文。

### `context.Background()` 和 `context.TODO()` 区别

- 都是用于创建空的、基础上下文的函数，它们在功能上是等效的，都返回一个空的 `context.Context`。然而，它们在语义上略有不同。
- **`context.Background()`：** 这个函数通常用作程序的顶层上下文。
- **`context.TODO()`：** 这个函数表示未指定的上下文。在某些情况下，如果你需要传递一个上下文，但是还没有明确的值可用，可以使用 `context.TODO()` 来表示“尚未提供的上下文”。

### 主要应用

- 上下文信息传递，比如处理HTTP请求，在请求处理链路上传递信息（requestId）
- 超时控制
- 可以撤销的方法调用

## 锁

锁是用来控制对共享资源的访问的机制，以确保在同一时刻只有一个goroutine能够访问该资源，从而避免数据竞争和并发问题。Go语言

### 并发安全

#### 互斥锁

`sync.Mutex`用于在**临界区域保护共享资源**。Mutex有两个主要方法：`Lock`和`Unlock`。`Lock`用于获取锁，而`Unlock`用于释放锁。

#### 读写锁

`sync.RWMutex`是对Mutex的扩展，支持读写锁。**在读取操作较多而写入较少的情况下**，RWMutex能够提供更好的性能。

#### 原子操作

原子操作可以在没有其他线程干扰的情况下执行，不会导致数据竞争。Go语言提供了`sync/atomic`包来支持原子操作。

#### 通道

可以使用无缓存通道来实现并发安全

#### redis分布式锁

在分布式系统中，为了防止多个客户端同时修改共享资源而导致数据不一致，常常需要使用分布式锁。Redis是一种常用的分布式缓存和消息中间件，可以通过Redis实现分布式锁。

使用了SET命令的NX（Not eXists）和EX（EXpire）

在使用锁的时候，可以设置锁的过期时间，确保即使在业务逻辑中发生故障时，锁也会在一段时间后自动释放。

### Mutex 有几种模式？

**正常模式**（非公平锁）：

goroutine默认为正常模式，所有等待锁的goroutine按照FIFO顺序等待。唤醒的groutine不会直接拥有锁，而是会和新的goroutine竞争。新的groutine更容易抢占，因为他正在CPU上执行，所以刚刚唤醒的groutine有很大可能在锁竞争中失败，这种情况下，这个被唤醒的goroutine会加入到等待队列的前面。

**饥饿模式**：

当一个goroutine等待锁时间超过1ms时，或者当前队列只剩下一个goroutine的时候，mutex 切换到饥饿模式。

饥饿模式下，直接有unlock把锁交给等待队列排在第一位的goroutine，同时新进来的goroutine不会参与抢锁，也不会进入自旋状态，会直接进入等待队列的尾部，这样解决了老的goroutine一直抢不到锁的场景。

### 悲观锁、乐观锁

**悲观锁：**当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。

**乐观锁**：乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，**所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，**如果冲突，则返回给用户异常信息，让用户决定如何去做。**乐观锁适用于读多写少的场景**，这样可以提高程序的吞吐量

### 死锁

互相等待，得不到释放。

- 在同一个协程中读写通道。
- 主goroutine在已经加锁的情况下再次尝试加锁，导致死锁。在实际应用中，循环等待、嵌套锁等情况都可能导致死锁。

## 协程和通道应用场景

拉去链上充值日志：

开启定时任务 -> 拉取链上交易日志（通过通道返回的结果数据） ->  开启多个协程处理日志（数据转换为业务数据）并储存到数据库

确认交易：

开启定时任务 -> 查询本地数据库（数量判断+分页查询）交易日志满足一定的区块高度（21） ->  通过工作池模式 将查询（链上交易）任务发送到任务通道中 -> 开启多个工作者并发查询链上交易 -> 将结果发送到结果通道中 -> 读取结果通道更新用户余额。

## channel

通道是Go语言中**协程间的通信方式**。通道借助Go语言调度器的设计，可以高效实现通道的堵塞/唤醒，进一步实现通道多路复用的机制。

### 无缓存通道

容量为0。在无缓存通道上的发送（`chan <- data`）和接收（`data <- chan`）操作都是阻塞的，要求发送方和接收方同时准备好。他的这种**同步的特性**，适用于两个协程之间的同步通信。

应用场景：

- 工作池：在工作池模型中，无缓存通道可以用于实现任务的分发和协程的同步。每个任务都会被发送到无缓存通道中，而一组协程会从通道中接收任务并执行。

### 缓存通道

缓存通道具有一个指定的容量，容量大于0。在缓存通道上的发送者只有在通道满时才会阻塞，而接收者只有在通道为空时才会阻塞。这使得**缓存通道可以支持异步的通信**，即发送和接收可以独立进行。

应用场景：

- 限制并发数量，当通道中缓存已满时，新的任务就无法进入，从而限制了并发的数量。
- 在事件发布订阅模型中，缓存通道可以用于实现一个简单的发布订阅系统，其中订阅者可以异步地处理发布者发送的事件。

### CSP

不要通过共享内存来通信，而要通过通信来实现内存共享。

Go 的并发编程的模型使用 goroutine 和 channel来实现内存同步访问控制，

### channel 的三种状态和三种操作结果

| 操作     | 空值(nil） | 非空已关闭 | 非空未关闭       |
| :------- | :--------- | :--------- | :--------------- |
| 关闭     | panic      | panic      | 成功关闭         |
| 发送数据 | 永久阻塞   | panic      | 阻塞或成功发送   |
| 接收数据 | 永久阻塞   | 永不阻塞   | 阻塞或者成功接收 |

## 协程

### 进程、线程、协程的区别

**进程（Process）：** 是应用程序的启动实例，有自己独立的内存空间。进程之间相互独立，通信需要使用进程间通信（IPC）机制。

**线程（Thread**）：CPU 调度的基本单位，多个线程之间可以共享进程的资源并**通过共享内存**来通信。

**协程（Coroutine）**： 轻量级的线程，和线程不同的是，操作系统内核感知不到协程的存在，协程的管理依赖Go语言运行时提供的调度器。

### 协程调度方式

协程是用户态的，协程从属于某一个线程的，协程与线程的对应关系是多对多的。**调度器可以将多个协程调度到一个线程中，一个协程也可能切换到多个线程中执行。**

### 调度策略

协程一般情况下是**协作式调度的**，当一个协程处理完自己的任务后，可以主动将执行权限让给其他协程，这意味着协程可以更好的在规定时间内完成任务，而不会轻易被抢占，**当一个协程运行了过长时间时，调度器才会强制抢占其执行。**

### 上下文切换

协程的速度要快于线程，其原因在于协程切换不用经过操作系统用户态与内核态的切换，并且Go语言中的协程切换只需要保存少量的状态和寄存器变量值（SP/BP/PC)，而线程切换会保留额外的寄存器变量值（如浮点寄存器）。

### 栈的大小

go语言中的协程大小默认为2KB，因此可以创建大量的协程。

线程的栈大小一般是在创建时指定的，为了避免出现栈溢出，默认的栈会相对较大（如：2M）这意味着消耗的虚拟内存较大，大大限制了线程创建的数量。

### GMP模型

GMP模型概括了协程和线程之间的关系。

- G - Goroutine，Go协程，是参与调度与执行的最小单位
- M - Machine，指的是系统级线程
- P - Processor，指的是逻辑处理器，P关联了的本地可运行G的队列(也称为LRQ)，最多可存放256个G。

**调度器是线程和协程之间桥梁。在任一时刻，一个P（调度器）可能在其本地包含多个（协程）G，同时一个P在任一时刻只能绑定一个（线程）M。**

GMP调度流程大致如下：

- 线程(M)想运行任务就需关联调度器(P)。
- 然从 调度器 的本地队列(LRQ)获取 协程
- 如果本地队列LRQ中没有可运行的协程G，线程M 会尝试从全局队列(GRQ)拿一批协程G放到调度器P的本地队列，
- 如果全局队列也未找到可运行的协程G，线程M会随机从其他调度器 P 的本地队列获取一半协程放到自己调度器 P 的本地队列。
- 拿到可运行的协程G之后，线程M 运行协程 G，协程G 执行之后，线程M 会从调度器 P 获取下一个 协程G，不断重复下去。

### 协程泄漏

协程泄漏是指在应用程序中创建的协程（goroutine）无法正常退出，导致其所占用的资源得不到释放。协程泄漏可能会导致内存泄漏或其他资源泄漏问题，最终影响应用程序的性能和稳定性。

可能导致协程泄漏的情况和解决方案：

- **未关闭的通道（Channel）：** 如果协程在等待一个通道的消息，而该通道永远不会被关闭，那么协程可能永远无法退出。确保在不再需要通道时及时关闭它，以通知相关协程退出。
- **协程阻塞：** 协程在执行期间阻塞，而没有条件可以使其退出。如：缺少接收器，导致发送阻塞。缺少发送器，导致接收阻塞。
- **缺少协程的退出条件：** 在协程中缺少退出条件，导致协程一直执行下去。确保在协程中有明确的退出条件。
- **未释放资源：** 如果在goroutine中使用了一些需要手动释放的资源（如文件句柄、数据库连接等），确保在goroutine结束时释放这些资源。
- **死锁**：多个协程由于竞争资源导致死锁。

协程泄漏的排查与解决方案：

- **使用`go vet`工具：** Go语言提供了`go vet`工具，它可以用于检查代码中的常见错误，包括协程泄漏。运行以下命令：
- **使用`goroutine`分析工具：** Go语言提供了`runtime/pprof`包，可以用于分析和诊断goroutine的问题。使用`pprof`工具可以查看运行时的goroutine数量和堆栈信息。
- **使用`defer`语句确保资源释放：** 在goroutine中使用`defer`语句，以确保在goroutine退出时执行资源释放操作。
- **合理使用`context`：** 使用`context`包来管理goroutine的生命周期，可以方便地取消或超时goroutine，确保它们能够正常退出。
- **使用`select`语句监听多个通道：** 如果在goroutine中使用多个通道，使用`select`语句可以避免因一个通道阻塞而导致整个goroutine泄漏。
- **记录和分析日志：** 在关键点记录日志，特别是在goroutine启动和退出时。这有助于追踪问题并及时发现协程泄漏。

## 性能分析

### 字符串拼接

常见的拼接方式：+、fmt.Sprintf、strings.Builder、bytes.Buffer、[]byte

`strings.Builder`、`bytes.Buffer` 和 `[]byte` 的性能差距不大，而且消耗的内存也十分接近，性能最好且消耗内存小，一般**推荐使用 `strings.Builder` 来拼接字符串**。

`string.Builder` 也提供了预分配内存的方式 `Grow`：

```go
func builderConcat(n int, str string) string {
	var builder strings.Builder
	builder.Grow(n * len(str))
	for i := 0; i < n; i++ {
		builder.WriteString(str)
	}
	return builder.String()
}
```

性能背后的原理：

- +：使用+拼接2个字符串时，会新开辟一个内存空间，然后将两个字符串拷贝过去。
- fmt.Sprintf：底层使用反射，消耗性能
- strings.Builder`和bytes.Buffer 底层都是 []byte 数组，他们的内存是以倍数申请的。但 `strings.Builder` 性能比 `bytes.Buffer` 略快约 10% 。一个比较重要的区别在于，`bytes.Buffer` 转化为字符串时重新申请了一块空间，存放生成的字符串变量，而 `strings.Builder` 直接将底层的 `[]byte` 转换成了字符串类型返回了回来。

### 切片

- Delete：切片的底层是数组，因此删除意味着后面的元素需要逐个向前移位。每次删除的复杂度为 O(N)，因此**切片不合适大量随机删除的场景**，这种场景下适合使用链表。删除后，将空余的位置置空，有助于垃圾回收。

- Insert：insert 和 append 类似。即在某个位置添加一个元素后，将该位置后面的元素再 append 回去。复杂度为 O(N)。因此，不适合大量随机插入的场景。

- Filter：当原切片不会再被使用时，就地 filter 方式是比较推荐的，可以节省内存空间。

  ```go
  n := 0
  for _, x := range a {
  	if keep(x) {
  		a[n] = x
      n++
  	}
  }
  a = a[:n]
  ```

- Append：在末尾追加元素，不考虑内存拷贝的情况，复杂度为 O(1)。在头部追加元素，时间和空间复杂度均为 O(N)，不推荐。

- Pop: 尾部删除元素，复杂度 O(1)头部删除元素，如果使用切片方式，复杂度为 O(1)。但是需要注意的是，**底层数组没有发生改变，第 0 个位置的内存仍旧没有释放。如果有大量这样的操作，头部的内存会一直被占用**。

**性能陷阱**：在已有切片的基础上进行切片，不会创建新的底层数组。因为原来的底层数组没有发生变化，内存会一直占用，直到没有变量引用该数组。比较推荐的做法，使用 `copy` 替代 `re-slice`。

```go
func lastNumsBySlice(origin []int) []int {
	return origin[len(origin)-2:]
}

func lastNumsByCopy(origin []int) []int {
	result := make([]int, 2)
	copy(result, origin[len(origin)-2:])
	return result
}
```

### for循环

range 在迭代过程中返回的是**迭代值的拷贝**，如果每次迭代的元素的内存占用很低，那么 for 和 range 的性能几乎是一样，例如 `[]int`。但是**如果迭代的元素内存占用较高**，例如一个包含很多属性的 struct 结构体，**那么 for 的性能将显著地高于 range**，有时候甚至会有上千倍的性能差异。对于这种场景，建议使用 for，如果使用 range，建议只迭代下标，通过下标访问迭代值，这种使用方式和 for 就没有区别了。**如果想使用 range 同时迭代下标和值，则需要将切片/数组的元素改为指针**，才能不影响性能。



### 传值 VS 传指针

传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致**内存分配逃逸到堆中**，**增加垃圾回收(GC)的负担**。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。

一般情况下，**对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能**。

### 空结构体节省内存空间

在 Go 语言中，我们可以使用 `unsafe.Sizeof` 计算出一个数据类型实例需要占用的字节数。

```go
func main() {
	fmt.Println(unsafe.Sizeof(struct{}{}))
}
```

也就是说，空结构体 struct{} 实例不占据任何的内存空间，因此被广泛作为占位符使用。比如：

- 实现集合(Set)，go语言中没有实现集合（Set），将 map 作为集合(Set)使用时，可以将值类型定义为空结构体，仅作为占位符使用即可。
- 不发送数据的通道(channel)，有时候使用 channel 不需要发送任何的数据，只用来通知子协程(goroutine)执行任务，或只用来控制协程并发度。这种情况下，使用空结构体作为占位符就非常合适了。
- 仅有方法的结构体

### 内存对齐

CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如 32 位的 CPU ，字长为 4 字节，那么 CPU 访问内存的单位也是 4 字节。

这么设计的目的，是减少 CPU 访问内存的次数，加大 CPU 访问内存的吞吐量。比如同样读取 8 个字节的数据，一次读取 4 个字节那么只需要读取 2 次。

