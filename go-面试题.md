

[TOC]

## new和make的区别？

- `new` 用于分配内存，但不初始化该内存，返回的是指向新分配的零值内存的指针。
- make 用于**slice,map,channel**等引用类型，并进行初始化，`make` 返回的是已初始化的非零值。


## go中的GMP模型

Go里面GMP分别代表：G：goroutine，M：线程（真正在CPU上跑的），P：逻辑处理器（或调度器）。

调度器是M和G之间桥梁。在任一时刻，一个P（调度器）可能在其本地包含多个（协程）G，同时一个P在任一时刻只能绑定一个（线程）M。

go进行调度过程：

- 某个线程尝试创建一个新的G，那么这个G就会被安排到这个线程的G本地队列LRQ中，如果LRQ满了，就会分配到全局队列GRQ中；

- 尝试获取当前线程的M，如果无法获取，就会从空闲的M列表中找一个，如果空闲列表也没有，那么就创建一个M，然后绑定G与P运行。

- 进入调度循环：

- - 找到一个合适的G
  - 执行G，完成以后退出

## go内存管理机制

Go语言的内存管理机制是通过垃圾回收（Garbage Collection，GC）来实现的。下面是Go语言内存管理的基本原理：

1. **自动内存分配：** Go语言使用自动内存分配，开发者无需手动分配和释放内存。这由垃圾回收器（Garbage Collector）负责。
2. **垃圾回收（GC）：** 垃圾回收是Go语言内存管理的核心机制。Go的垃圾回收器会定期扫描程序中不再使用的内存，将其标记为可回收的垃圾，然后释放这些垃圾占用的内存。这使得开发者不必手动管理内存，大大简化了内存管理的复杂性。
3. **并发垃圾回收：** Go的垃圾回收器是并发的，它可以在程序继续执行的同时进行垃圾回收。这意味着垃圾回收不会阻塞整个程序的执行，减小了对程序性能的影响。
4. **分代回收：** Go的垃圾回收器采用分代回收策略。它将内存分为不同的代（generation），一般分为新生代和老生代。新分配的对象首先被分配到新生代，只有经过一定次数的垃圾回收后，仍然存活的对象才会被晋升到老生代。分代回收能够更有效地处理不同生命周期的对象。
5. **写屏障（Write Barrier）：** Go语言的垃圾回收器使用写屏障技术，即在进行垃圾回收时，会拦截对指针的写入操作，以便准确地追踪对象的引用关系。这有助于垃圾回收器准确地标记和回收不再被引用的对象。
6. **内存分配器：** Go语言的运行时系统包含了一个内存分配器，负责分配和释放内存。内存分配器会根据对象的大小选择合适的内存池，以提高内存分配效率。

## 协程泄漏

Go协程泄漏是指在程序运行过程中，创建的goroutine无法正常退出并释放资源，导致这些goroutine一直存在，最终导致内存泄漏或其他资源泄漏的问题。协程泄漏可能会影响程序性能并导致不稳定的行为。以下是一些可能导致Go协程泄漏的原因以及解决方案：

### 常见的协程泄漏原因：

1. **未关闭的通道：** 如果一个goroutine在等待从通道中接收数据，但通道永远不会被关闭，这个goroutine可能会一直阻塞。确保在合适的时机关闭通道，以便goroutine可以正常退出。
2. **未释放资源：** 如果在goroutine中使用了一些需要手动释放的资源（如文件句柄、数据库连接等），确保在goroutine结束时释放这些资源。
3. **循环引用：** 如果在goroutine中存在循环引用，可能导致垃圾回收器无法正确回收内存。确保在goroutine中避免循环引用。

### 协程泄漏的排查与解决方案：

1. **使用`go vet`工具：** Go语言提供了`go vet`工具，它可以用于检查代码中的常见错误，包括协程泄漏。运行以下命令：

   ```shell
   go vet ./...
   ```

2. **使用`goroutine`分析工具：** Go语言提供了`runtime/pprof`包，可以用于分析和诊断goroutine的问题。使用`pprof`工具可以查看运行时的goroutine数量和堆栈信息。

3. **使用`defer`语句确保资源释放：** 在goroutine中使用`defer`语句，以确保在goroutine退出时执行资源释放操作。

4. **合理使用`context`：** 使用`context`包来管理goroutine的生命周期，可以方便地取消或超时goroutine，确保它们能够正常退出。

5. **使用`select`语句监听多个通道：** 如果在goroutine中使用多个通道，使用`select`语句可以避免因一个通道阻塞而导致整个goroutine泄漏。

6. **记录和分析日志：** 在关键点记录日志，特别是在goroutine启动和退出时。这有助于追踪问题并及时发现协程泄漏。

## redis

Redis（Remote Dictionary Server）是一种开源的内存数据库，通常被用作缓存、消息队列、实时分析（例如计数器和统计数据）以及会话存储。

### **Redis 是什么？它的特点是什么？**

- Redis 是一个开源的内存数据库，它支持多种数据结构，包括字符串、列表、集合、有序集合、哈希表等。
- 特点包括高性能、持久化、支持数据复制、支持多种数据结构、原子性操作等。

### 使用场景

1. **缓存**: Redis 最常见的用途是作为缓存存储。由于它将数据存储在内存中，因此访问速度非常快。通过将常用的查询结果或计算结果存储在 Redis 中，可以减轻数据库的负担，提高应用程序的响应速度。
2. **会话存储**: Redis 可以用作分布式会话存储，特别是在负载均衡的环境中。将用户会话数据存储在 Redis 中，可以确保用户在多个服务器之间的无缝切换而无需重新登录。
3. **消息队列**: Redis 支持发布/订阅模式，使其成为一个强大的消息队列系统。应用程序可以使用 Redis 的发布/订阅功能实现异步通信，解耦不同组件之间的操作。
4. **实时计数器和统计数据**: Redis 提供了一些原子操作，使其非常适合用作计数器。这可用于实时跟踪网站访问次数、用户在线状态等。在统计数据方面，Redis 的有序集合（Sorted Sets）可以用来存储和查询排名信息。
5. **地理空间索引**: Redis 6.0 引入了地理空间索引功能，允许存储和查询地理位置信息。这使得 Redis 可以用于构建位置服务和地理信息系统。
6. **分布式锁**: 在分布式系统中，使用 Redis 可以实现分布式锁，确保多个进程或服务不会同时修改共享资源，从而避免竞态条件。
7. **实时消息推送**: 利用 Redis 的发布/订阅功能，可以实现实时消息推送。这对于构建即时聊天应用或实时通知系统非常有用。
8. **任务队列**: 将任务放入 Redis 队列，然后由工作者进程异步处理这些任务。这在处理后台任务、定时任务等方面非常有用。

总体而言，Redis 是一个多功能的数据存储系统，它在内存中操作数据，提供了高性能和灵活性，使其成为许多不同场景下的理想选择。