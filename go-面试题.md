

[TOC]



## 方法

在调用方法的时候，值类型既可以调用`值接收者`的方法，也可以调用`指针接收者`的方法；指针类型既可以调用`指针接收者`的方法，也可以调用`值接收者`的方法。

也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。

实际上，当类型和方法的接收者类型不同时，其实是编译器在背后做了一些工作，用一个表格来呈现：

| -              | 值接收者                                                     | 指针接收者                                                   |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 值类型调用者   | 方法会使用调用者的一个副本，类似于“传值”                     | 使用值的引用来调用方法，上例中，`qcrao.growUp()` 实际上是 `(&qcrao).growUp()` |
| 指针类型调用者 | 指针被解引用为值，上例中，`stefno.howOld()` 实际上是 `(*stefno).howOld()` | 实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针 |

### 值接收者和指针接收者

实现了接收者是值类型的方法，**相当于自动实现了接收者是指针类型的方法**；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。

详细示例：https://golang.design/go-questions/interface/receiver/

如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。

### 值接收者和指针接收者两者分别在何时使用 

使用指针作为方法的接收者的理由：

- 方法能够修改接收者指向的值。
- 避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。

是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的`本质`。

如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 `header`， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 `header`，而 `header` 本身就是为复制设计的。

如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份`实体`。

## 接口

`iface` 和 `eface` 都是 Go 中描述接口的底层结构体，区别在于 `iface` 描述的接口包含方法，而 `eface` 则是不包含任何方法的空接口：`interface{}`。

```go
type iface struct {
	tab  *itab						//接口的类型以及赋给这个接口的实体类型： 动态类型
	data unsafe.Pointer		// 指向接口具体的值： 动态值
}

type itab struct {
	inter  *interfacetype
	_type  *_type
	link   *itab
	hash   uint32 // copy of _type.hash. Used for type switches.
	bad    bool   // type does not implement interface
	inhash bool   // has this itab been added to hash?
	unused [2]byte
	fun    [1]uintptr // variable sized
}
```

接口值的零值是指**`动态类型`和`动态值`都为 `nil`**。当仅且当这两部分的值都为 `nil` 的情况下，这个接口值就才会被认为 `接口值 == nil`。



## 数组和切片

### 数组

数组是值类型，将一个数组赋值给另外一个数组时，会复制整个数组的值。数组长度在创建时确定，不可更改

### 切片

切片引用类型，当将一个切片赋值给另一个切片时，它们实际上引用相同的底层数组，修改值将会影响其他的切片。

切片长度：**切片的起始位置到切片的结束位置的元素数量**

切片容量：**切片的起始位置到底层数组的末尾的元素数量**

#### 切片底层

Go切片(slice)的实现可以在源码包`src/runtime/slice.go`中找到。在源码中，slice的数据结构定义如下。

```go
type slice struct {
	array unsafe.Pointer	//指向底层数组的指针
	len int					//切片长度
	cap int					//切片容量，底层数组
}
```

#### 切片拷贝

使用Copy拷贝切片时，会将源切片中的数据逐个拷贝到目的切片指向的数组中，拷贝数量取两个切片的最小值， 不会发生扩容。

#### 切片扩容

扩容操作只关心容量，会把原slice的数据拷贝至新slice中，扩容规则：

go 1.18之前：

- 原slice的容量小于1024，则新slice的容量将扩大为原来的2倍；
- 原slice的容量大于1024，则新的slice的容量将扩大为原来的1.25倍；

go 1.18更新之后：

当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap = oldcap+(oldcap+3*256)/4

#### 陷阱

##### 切片扩容引发的问题

因为有扩容机制。所以无法保证**原始的slice**和用append后的**新slice**指向同一个底层数组，也无法证明它们就指向不同的底层数组。同样，我们也无法假设旧slice上对元素的操作会或者不会影响新的slice元素。所以，通常我们将append的调用结果再次赋给传入append的slice。

##### 使用range进行切片迭代 （go1.22之前的版本中）

当使用range进行切片迭代时，range创建了每个元素的副本，而不是直接返回对该元素的引用。**v值会在每次迭代时被重新赋值，且循环中每次都是使用的v变量**

并发中捕获for range变量

```go
func main() {
	done := make(chan bool)
	values := []string{"a", "b", "c"}
	for _, v := range values {
		go func() {
			fmt.Println(v)
			done <- true
		}()
	}
	// wait for all goroutines to complete before exiting
	for _ = range values {
		<-done
	}
	// 打印结果 c, c, c
}

```

在闭包中

```go
func main() {
	var prints []func()
	for i := 1; i <= 3; i++ {
		prints = append(prints, func() { fmt.Println(i) })
	}
	for _, p := range prints {
		p()
	}
	// 打印 4, 4, 4
}
```

## Map

Go 语言采用的是哈希表，并且使用链表解决哈希冲突，（即在同一个桶中使用链表来存储具有相同哈希码的键值对）

每个桶中保存了8个kv对，如果8个满了，又来了一个key落在了这个桶里，会使用overflow连接下一个桶(溢出桶)。

内存模型

```go
// A header for a Go map.
type hmap struct {
    // 元素个数，调用 len(map) 时，直接返回此值
	count     int
	flags     uint8
	// buckets 的对数 log_2
	B         uint8
	// overflow 的 bucket 近似数
	noverflow uint16
	// 计算 key 的哈希的时候会传入哈希函数
	hash0     uint32
    // 指向 buckets 数组，大小为 2^B
    // 如果元素个数为0，就为 nil
	buckets    unsafe.Pointer
	// 等量扩容的时候，buckets 长度和 oldbuckets 相等
	// 双倍扩容的时候，buckets 长度会是 oldbuckets 的两倍
	oldbuckets unsafe.Pointer
	// 指示扩容进度，小于此地址的 buckets 迁移完成
	nevacuate  uintptr
	extra *mapextra // optional fields
}
```

![image-20240221162931584](./img/image-20240221162931584.png)

### map 获取数据流程

- 计算key的hash值
- 通过最后的“B”位来确定在哪号桶
- 根据key对应的hash值前8位快速确定是在这个桶的哪个位置**（额外说明一下，在bmap中存放了每个key对应的tophash，是key的哈希值前8位),一旦发现前8位一致，则会执行下一步**
- 对比key完整的hash是否匹配，如果匹配则获取对应value
- 如果都没有找到，就去连接的下一个溢出桶中找

### map的赋值流程

- 通过key的hash值后“B”位确定是哪一个桶
- 遍历当前桶，通过key的tophash和hash值，防止key重复，然后**找到第一个可以插入的位置**，即空位置处存储数据。
- 如果**当前桶元素已满，会通过overflow链接创建一个新的桶**，来存储数据。

**关于hash冲突**：当两个不同的 key 落在同一个桶中，就是发生了哈希冲突。冲突的解决手段是采用链表法：在 桶 中，从前往后找到第一个空位进行插入。如果8个kv满了，那么当前桶就会连接到下一个溢出桶（bmap）。

### 扩容

当 map 中的键值对数量达到一定阈值时，Go 语言会触发 map 的扩容操作。扩容时，Go 会创建一个新的更大的哈希表，然后将旧表中的键值对重新哈希并存储到新表中。这样做的目的是为了减小哈希冲突，提高哈希表的性能。在扩容过程中，所有读写操作仍然是安全的，因为 Go 语言会使用锁来保护这个操作。

### **无序性：** 

map 是无序的，即遍历 map 的顺序与插入键值对的顺序无关。这是因为**哈希表的索引位置**是通过**哈希码**计算得到的，不与键值对的插入顺序有直接关系。

## new和make的区别？

- `new` 用于分配内存，但不初始化该内存，返回的是指向新分配的零值内存的指针。
- make 用于**slice,map,channel**等引用类型，并进行初始化，`make` 返回的是已初始化的非零值。


## go中的GMP模型

Go里面GMP分别代表：G：goroutine，M：线程（真正在CPU上跑的），P：逻辑处理器（或调度器）。

调度器是M和G之间桥梁。在任一时刻，一个P（调度器）可能在其本地包含多个（协程）G，同时一个P在任一时刻只能绑定一个（线程）M。

go进行调度过程：

- 某个线程尝试创建一个新的G，那么这个G就会被安排到这个线程的G本地队列LRQ中，如果LRQ满了，就会分配到全局队列GRQ中；

- 尝试获取当前线程的M，如果无法获取，就会从空闲的M列表中找一个，如果空闲列表也没有，那么就创建一个M，然后绑定G与P运行。

- 进入调度循环：

- - 找到一个合适的G
  - 执行G，完成以后退出

## go内存管理机制

Go语言的内存管理机制是通过垃圾回收（Garbage Collection，GC）来实现的。下面是Go语言内存管理的基本原理：

1. **自动内存分配：** Go语言使用自动内存分配，开发者无需手动分配和释放内存。这由垃圾回收器（Garbage Collector）负责。
2. **垃圾回收（GC）：** 垃圾回收是Go语言内存管理的核心机制。Go的垃圾回收器会定期扫描程序中不再使用的内存，将其标记为可回收的垃圾，然后释放这些垃圾占用的内存。这使得开发者不必手动管理内存，大大简化了内存管理的复杂性。
3. **并发垃圾回收：** Go的垃圾回收器是并发的，它可以在程序继续执行的同时进行垃圾回收。这意味着垃圾回收不会阻塞整个程序的执行，减小了对程序性能的影响。
4. **分代回收：** Go的垃圾回收器采用分代回收策略。它将内存分为不同的代（generation），一般分为新生代和老生代。新分配的对象首先被分配到新生代，只有经过一定次数的垃圾回收后，仍然存活的对象才会被晋升到老生代。分代回收能够更有效地处理不同生命周期的对象。
5. **写屏障（Write Barrier）：** Go语言的垃圾回收器使用写屏障技术，即在进行垃圾回收时，会拦截对指针的写入操作，以便准确地追踪对象的引用关系。这有助于垃圾回收器准确地标记和回收不再被引用的对象。
6. **内存分配器：** Go语言的运行时系统包含了一个内存分配器，负责分配和释放内存。内存分配器会根据对象的大小选择合适的内存池，以提高内存分配效率。

## 通道



## 协程泄漏

Go协程泄漏是指在程序运行过程中，创建的goroutine无法正常退出并释放资源，导致这些goroutine一直存在，最终导致内存泄漏或其他资源泄漏的问题。协程泄漏可能会影响程序性能并导致不稳定的行为。以下是一些可能导致Go协程泄漏的原因以及解决方案：

### 常见的协程泄漏原因：

1. **未关闭的通道：** 如果一个goroutine在等待从通道中接收数据，但通道永远不会被关闭，这个goroutine可能会一直阻塞。确保在合适的时机关闭通道，以便goroutine可以正常退出。
2. **未释放资源：** 如果在goroutine中使用了一些需要手动释放的资源（如文件句柄、数据库连接等），确保在goroutine结束时释放这些资源。
3. **循环引用：** 如果在goroutine中存在循环引用，可能导致垃圾回收器无法正确回收内存。确保在goroutine中避免循环引用。

### 协程泄漏的排查与解决方案：

1. **使用`go vet`工具：** Go语言提供了`go vet`工具，它可以用于检查代码中的常见错误，包括协程泄漏。运行以下命令：

   ```shell
   go vet ./...
   ```

2. **使用`goroutine`分析工具：** Go语言提供了`runtime/pprof`包，可以用于分析和诊断goroutine的问题。使用`pprof`工具可以查看运行时的goroutine数量和堆栈信息。

3. **使用`defer`语句确保资源释放：** 在goroutine中使用`defer`语句，以确保在goroutine退出时执行资源释放操作。

4. **合理使用`context`：** 使用`context`包来管理goroutine的生命周期，可以方便地取消或超时goroutine，确保它们能够正常退出。

5. **使用`select`语句监听多个通道：** 如果在goroutine中使用多个通道，使用`select`语句可以避免因一个通道阻塞而导致整个goroutine泄漏。

6. **记录和分析日志：** 在关键点记录日志，特别是在goroutine启动和退出时。这有助于追踪问题并及时发现协程泄漏。

## redis

Redis（Remote Dictionary Server）是一种开源的内存数据库，通常被用作缓存、消息队列、实时分析（例如计数器和统计数据）以及会话存储。

### **Redis 是什么？它的特点是什么？**

- Redis 是一个开源的内存数据库，它支持多种数据结构，包括字符串、列表、集合、有序集合、哈希表等。
- 特点包括高性能、持久化、支持数据复制、支持多种数据结构、原子性操作等。

### 使用场景

1. **缓存**: Redis 最常见的用途是作为缓存存储。由于它将数据存储在内存中，因此访问速度非常快。通过将常用的查询结果或计算结果存储在 Redis 中，可以减轻数据库的负担，提高应用程序的响应速度。
2. **会话存储**: Redis 可以用作分布式会话存储，特别是在负载均衡的环境中。将用户会话数据存储在 Redis 中，可以确保用户在多个服务器之间的无缝切换而无需重新登录。
3. **消息队列**: Redis 支持发布/订阅模式，使其成为一个强大的消息队列系统。应用程序可以使用 Redis 的发布/订阅功能实现异步通信，解耦不同组件之间的操作。
4. **实时计数器和统计数据**: Redis 提供了一些原子操作，使其非常适合用作计数器。这可用于实时跟踪网站访问次数、用户在线状态等。在统计数据方面，Redis 的有序集合（Sorted Sets）可以用来存储和查询排名信息。
5. **地理空间索引**: Redis 6.0 引入了地理空间索引功能，允许存储和查询地理位置信息。这使得 Redis 可以用于构建位置服务和地理信息系统。
6. **分布式锁**: 在分布式系统中，使用 Redis 可以实现分布式锁，确保多个进程或服务不会同时修改共享资源，从而避免竞态条件。
7. **实时消息推送**: 利用 Redis 的发布/订阅功能，可以实现实时消息推送。这对于构建即时聊天应用或实时通知系统非常有用。
8. **任务队列**: 将任务放入 Redis 队列，然后由工作者进程异步处理这些任务。这在处理后台任务、定时任务等方面非常有用。

总体而言，Redis 是一个多功能的数据存储系统，它在内存中操作数据，提供了高性能和灵活性，使其成为许多不同场景下的理想选择。

## Mysql

mysql性能优化



## 微服务

